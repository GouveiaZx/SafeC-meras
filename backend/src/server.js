import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import compression from 'compression';
import rateLimit from 'express-rate-limit';
import { createServer } from 'http';
import { Server } from 'socket.io';
import { join, dirname } from 'path';
import { fileURLToPath } from 'url';
import dotenv from 'dotenv';

// Configurar __dirname para ES modules
const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Carregar vari√°veis de ambiente
// Primeiro carrega .env padr√£o
dotenv.config({ path: join(__dirname, '../.env') });
// Depois carrega .env.local se existir (sobrescreve configura√ß√µes para desenvolvimento local)
dotenv.config({ path: join(__dirname, '../.env.local') });

// Importar middlewares
import { errorHandler, notFoundHandler } from './middleware/errorHandler.js';
import { requestLogger } from './middleware/requestLogger.js';
import { authenticateToken } from './middleware/auth.js';
import { authenticateSupabaseToken } from './middleware/supabaseAuth.js';
import { corsConfig } from './config/cors.js';

// Importar rotas
import authRoutes from './routes/auth.js';
import userRoutes from './routes/users.js';
import cameraRoutes from './routes/cameras.js';
import streamRoutes from './routes/streams.js';
import recordingRoutes from './routes/recordings.js';
import recordingFilesRoutes from './routes/recordingFiles.js';
import dashboardRoutes from './routes/dashboard.js';
import metricsRoutes from './routes/metrics.js';
import logsRoutes from './routes/logs.js';
import discoveryRoutes from './routes/discovery.js';
import workerRoutes from './routes/worker.js';
import hookRoutes from './routes/hooks.js';
import healthRoutes from './routes/health.js';
import segmentationRoutes, { injectSegmentationService } from './routes/segmentation.js';

// Importar servi√ßos
import streamingService from './services/StreamingService.js';
import cameraMonitoringService from './services/CameraMonitoringService.js';
import MetricsService from './services/MetricsService.js';
import SegmentationService from './services/SegmentationService.js';
import RecordingMonitorService from './services/RecordingMonitorService.js';
import recordingFinalizationService from './services/RecordingFinalizationService.js';
import { initializeSocket } from './controllers/socketController.js';

// Configura√ß√µes
const PORT = process.env.PORT || 3002;
const NODE_ENV = process.env.NODE_ENV || 'development';

// Criar aplica√ß√£o Express
const app = express();
const server = createServer(app);
const io = new Server(server, {
  cors: {
    origin: process.env.FRONTEND_URL || "http://localhost:5173",
    methods: ["GET", "POST", "PUT", "DELETE"],
    credentials: true
  },
  transports: ['websocket', 'polling']
});

// Configurar CORS usando a configura√ß√£o completa
app.use(cors(corsConfig));

// Middlewares de seguran√ßa
app.use(helmet({
  crossOriginEmbedderPolicy: false,
  contentSecurityPolicy: {
    directives: {
      defaultSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      scriptSrc: ["'self'"],
      imgSrc: ["'self'", "data:", "blob:"],
      mediaSrc: ["'self'", "blob:", "http://localhost:3010", "http://127.0.0.1:3010", "http://localhost:3002", "http://127.0.0.1:3002", "http://localhost:3000", "http://127.0.0.1:3000"],
      connectSrc: ["'self'", "ws:", "wss:", "http://localhost:3010", "http://127.0.0.1:3010", "http://localhost:3002", "http://127.0.0.1:3002"],
    },
  },
}));

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutos
  max: NODE_ENV === 'production' ? 100 : 10000, // Limite muito alto para desenvolvimento
  message: {
    error: 'Muitas requisi√ß√µes deste IP, tente novamente em 15 minutos.'
  },
  standardHeaders: true,
  legacyHeaders: false,
  handler: (req, res) => {
    console.log('üö´ [RATE LIMIT] Requisi√ß√£o bloqueada:', {
      ip: req.ip,
      path: req.path,
      method: req.method,
      headers: Object.keys(req.headers)
    });
    res.status(429).json({
      error: 'Muitas requisi√ß√µes deste IP, tente novamente em 15 minutos.'
    });
  }
});

app.use('/api/', limiter);

// Middlewares gerais
app.use(compression());
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));
app.use(requestLogger);

// Middleware de autentica√ß√£o para rotas protegidas
app.use('/api/users', authenticateToken);
app.use('/api/cameras', authenticateToken);
// Nota: /api/streams usa seu pr√≥prio middleware de autentica√ß√£o HLS
// Aplicar autentica√ß√£o apenas para rotas espec√≠ficas de recordings (excluindo stream)
app.use('/api/recordings', (req, res, next) => {
  console.log('üîç [RECORDINGS MIDDLEWARE] Requisi√ß√£o recebida:', {
    method: req.method,
    path: req.path,
    originalUrl: req.originalUrl,
    headers: Object.keys(req.headers)
  });
  
  // Pular autentica√ß√£o global para rotas de stream (elas t√™m seu pr√≥prio middleware)
  // req.path ser√° algo como '/f2b8ef04-fada-4d7f-8542-77ca2b0bad8a/stream'
  if (req.path.includes('/stream') || req.path.includes('/download')) {
    console.log('üîì [AUTH BYPASS] Pulando autentica√ß√£o global para rota de stream/download:', req.path);
    return next();
  }
  console.log('üîê [AUTH APPLY] Aplicando autentica√ß√£o global para rota:', req.path);
  return authenticateToken(req, res, next);
});
app.use('/api/dashboard', authenticateToken);
app.use('/api/metrics', authenticateToken);
app.use('/api/logs', authenticateToken);
app.use('/api/discovery', authenticateToken);
// app.use('/api/worker', authenticateToken); // REMOVIDO: Worker usa seu pr√≥prio sistema de autentica√ß√£o
app.use('/api/segmentation', authenticateToken);

// Rota de health check (sem autentica√ß√£o)
app.get('/health', (req, res) => {
  res.json({
    status: 'OK',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    environment: NODE_ENV,
    version: process.env.npm_package_version || '1.0.0'
  });
});

// Rotas da API
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/recordings', recordingRoutes); // Movido para antes de cameras para evitar conflito de rotas
app.use('/api/recording-files', recordingFilesRoutes); // Rota para servir arquivos MP4 diretamente
app.use('/api/cameras', cameraRoutes);
app.use('/api/streams', streamRoutes);
app.use('/api/dashboard', dashboardRoutes);
app.use('/api/metrics', metricsRoutes);
app.use('/api/logs', logsRoutes);
app.use('/api/discovery', discoveryRoutes);
// PRODU√á√ÉO: Rotas de simula√ß√£o removidas
// app.use('/api/simulation', simulationRoutes);
app.use('/api/worker', workerRoutes);
app.use('/api/hook', hookRoutes);
app.use('/api/health', healthRoutes);
app.use('/api/segmentation', segmentationRoutes);

// REMOVIDO POR SEGURAN√áA: Exposi√ß√£o est√°tica de streams sem autentica√ß√£o
// Streams devem ser servidos atrav√©s da API com autentica√ß√£o adequada
// Use /api/streams/:id para acessar streams com seguran√ßa

// REMOVIDO: Rota est√°tica /recordings removida por seguran√ßa
// Todo acesso a grava√ß√µes deve ser feito via /api/recording-files com autentica√ß√£o

// Middleware de tratamento de erros
app.use(notFoundHandler);
app.use(errorHandler);

// Configura√ß√£o do Socket.IO
initializeSocket(io);

// Tornar io dispon√≠vel globalmente para outros m√≥dulos
app.set('io', io);

// Vari√°vel global para o servi√ßo de segmenta√ß√£o
let globalSegmentationService = null;

// Fun√ß√£o para inicializar servi√ßos
async function initializeServices() {
  console.log('üîß Inicializando servi√ßos...');
  
  // Aguardar inicializa√ß√£o do StreamingService
  try {
    console.log('‚ö†Ô∏è StreamingService temporariamente desabilitado (Docker n√£o dispon√≠vel)');
    // await streamingService.init();
    // console.log('‚úÖ StreamingService inicializado');
  } catch (error) {
    console.error('‚ùå Erro ao inicializar StreamingService:', error);
    throw error;
  }

  // Inicializar servi√ßo de monitoramento de c√¢meras
  try {
    console.log('‚ö†Ô∏è CameraMonitoringService temporariamente desabilitado (Docker n√£o dispon√≠vel)');
    // await cameraMonitoringService.initialize(streamingService);
    // cameraMonitoringService.startMonitoring();
    // console.log('‚úÖ CameraMonitoringService inicializado');
  } catch (error) {
    console.error('‚ùå Erro ao inicializar CameraMonitoringService:', error);
  }

  // DESABILITADO: RecordingMonitorService (servi√ßo redundante)
  try {
    console.log('‚ö†Ô∏è RecordingMonitorService DESABILITADO - usando apenas RecordingService');
    // await RecordingMonitorService.start();
    // console.log('‚úÖ RecordingMonitorService inicializado (automa√ß√£o de 30s ativa)');
    
    // Adicionar ao contexto global para uso em rotas se necess√°rio
    // app.locals.recordingMonitor = RecordingMonitorService;
  } catch (error) {
    console.error('‚ùå Erro ao inicializar RecordingMonitorService:', error);
  }

  // DESABILITADO: RecordingFinalizationService (servi√ßo redundante)
  try {
    console.log('‚ö†Ô∏è RecordingFinalizationService DESABILITADO - usando apenas RecordingService');
    // recordingFinalizationService.start();
    // console.log('‚úÖ RecordingFinalizationService inicializado');
    
    // Adicionar ao contexto global para uso em rotas se necess√°rio
    // app.locals.recordingFinalizationService = recordingFinalizationService;
  } catch (error) {
    console.error('‚ùå Erro ao inicializar RecordingFinalizationService:', error);
  }

  // Iniciar coleta de m√©tricas
  try {
    await MetricsService.startCollection(5000);
    console.log(`üìà Coleta de m√©tricas iniciada`);
  } catch (error) {
    console.error('Erro ao iniciar coleta de m√©tricas:', error);
  }

  // Iniciar job de sincroniza√ß√£o de grava√ß√µes
  try {
    const { default: recordingSyncJob } = await import('./jobs/recordingSyncJob.js');
    await recordingSyncJob.initialize();
    recordingSyncJob.start();
    console.log('üîÑ Recording Sync Job iniciado');
    
    // Adicionar ao contexto global para monitoramento
    app.locals.recordingSyncJob = recordingSyncJob;
  } catch (error) {
    console.error('‚ùå Erro ao inicializar Recording Sync Job:', error);
  }

  // DESABILITADO: SegmentationService (servi√ßo redundante)
  try {
    console.log('‚ö†Ô∏è SegmentationService DESABILITADO - grava√ß√£o ser√° controlada manualmente');
    // globalSegmentationService = new SegmentationService();
    // globalSegmentationService.start();
    // Injetar o servi√ßo nas rotas
    // injectSegmentationService(globalSegmentationService);
    // console.log('‚úÖ SegmentationService inicializado e iniciado');
  } catch (error) {
    console.error('‚ùå Erro ao inicializar SegmentationService:', error);
  }

  // Inicializar servi√ßo de grava√ß√£o
  try {
    // O RecordingService j√° √© inicializado automaticamente no construtor
    console.log(`üé• Servi√ßo de grava√ß√£o inicializado`);
    
    // Agendar processamento autom√°tico da fila de uploads (a cada 5 minutos)
    const scheduleUploadQueue = () => {
      setInterval(async () => {
        try {
          const RecordingService = (await import('./services/RecordingService.js')).default;
          const result = await RecordingService.processUploadQueue();
          
          if (result.processed > 0) {
            console.log(`üì§ Fila de upload processada: ${result.processed} processados, ${result.success} sucessos, ${result.failed} falhas`);
          }
        } catch (error) {
          console.error('‚ùå Erro no processamento autom√°tico da fila de upload:', error);
        }
      }, 5 * 60 * 1000); // A cada 5 minutos
      
      console.log('üì§ Processamento autom√°tico da fila de upload agendado (a cada 5 minutos)');
    };
    
    scheduleUploadQueue();
    
    // Agendar atualiza√ß√£o autom√°tica de estat√≠sticas das grava√ß√µes (a cada hora)
    const scheduleStatisticsUpdate = () => {
      setInterval(async () => {
        try {
          const RecordingService = (await import('./services/RecordingService.js')).default;
          const result = await RecordingService.updateRecordingStatistics();
          
          if (result.updated > 0) {
            console.log(`üìä Estat√≠sticas atualizadas: ${result.updated} grava√ß√µes processadas`);
          }
        } catch (error) {
          console.error('‚ùå Erro na atualiza√ß√£o autom√°tica de estat√≠sticas:', error);
        }
      }, 60 * 60 * 1000); // A cada 1 hora
      
      console.log('üìä Atualiza√ß√£o autom√°tica de estat√≠sticas agendada (a cada hora)');
    };
    
    scheduleStatisticsUpdate();
    
    // Agendar limpeza autom√°tica de grava√ß√µes antigas (diariamente √†s 2:00 AM)
    const scheduleRecordingCleanup = () => {
      const now = new Date();
      const nextCleanup = new Date();
      nextCleanup.setHours(2, 0, 0, 0); // 2:00 AM
      
      // Se j√° passou das 2:00 AM hoje, agendar para amanh√£
      if (now > nextCleanup) {
        nextCleanup.setDate(nextCleanup.getDate() + 1);
      }
      
      const timeUntilCleanup = nextCleanup.getTime() - now.getTime();
      
      setTimeout(async () => {
        try {
          console.log('üßπ Executando limpeza autom√°tica de grava√ß√µes antigas...');
          const RecordingService = (await import('./services/RecordingService.js')).default;
          const result = await RecordingService.cleanupOldRecordings();
          console.log(`‚úÖ Limpeza autom√°tica conclu√≠da: ${result.message}`);
        } catch (error) {
          console.error('‚ùå Erro na limpeza autom√°tica de grava√ß√µes:', error);
        }
        
        // Reagendar para o pr√≥ximo dia
        setInterval(async () => {
          try {
            console.log('üßπ Executando limpeza autom√°tica de grava√ß√µes antigas...');
            const RecordingService = (await import('./services/RecordingService.js')).default;
            const result = await RecordingService.cleanupOldRecordings();
            console.log(`‚úÖ Limpeza autom√°tica conclu√≠da: ${result.message}`);
          } catch (error) {
            console.error('‚ùå Erro na limpeza autom√°tica de grava√ß√µes:', error);
          }
        }, 24 * 60 * 60 * 1000); // A cada 24 horas
        
      }, timeUntilCleanup);
      
      console.log(`üïê Pr√≥xima limpeza autom√°tica agendada para: ${nextCleanup.toLocaleString('pt-BR')}`);
    };
    
    scheduleRecordingCleanup();
    
  } catch (error) {
    console.error('Erro ao inicializar servi√ßo de grava√ß√£o:', error);
  }

  // Inicializar c√¢meras automaticamente ap√≥s 10 segundos
  // setTimeout(async () => {
  //   try {
  //     console.log('üé¨ Iniciando processo autom√°tico de ativa√ß√£o das c√¢meras...');
  //     const { default: startCameraStreaming } = await import('./scripts/startCameraStreaming.js');
  //     await startCameraStreaming();
  //     console.log('‚úÖ Processo de ativa√ß√£o das c√¢meras conclu√≠do');
  //   } catch (error) {
  //     console.error('‚ùå Erro na inicializa√ß√£o autom√°tica das c√¢meras:', error);
  //   }
  // }, 10000); // Aguardar 10 segundos para todos os servi√ßos estarem prontos
  console.log('‚ö†Ô∏è Ativa√ß√£o autom√°tica de c√¢meras desabilitada (Docker n√£o dispon√≠vel)');
}

// Iniciar servidor
async function startServer() {
  try {
    // Primeiro inicializar todos os servi√ßos
    await initializeServices();
    
    // Depois iniciar o servidor
    server.listen(PORT, () => {
      console.log(`üöÄ Servidor NewCAM Backend rodando na porta ${PORT}`);
      console.log(`üìä Ambiente: ${NODE_ENV}`);
      console.log(`üîó Health check: http://localhost:${PORT}/health`);
      
      if (NODE_ENV === 'development') {
        console.log(`üìù Documenta√ß√£o da API: http://localhost:${PORT}/api/docs`);
      }
    });
  } catch (error) {
    console.error('‚ùå Erro ao inicializar servidor:', error);
    process.exit(1);
  }
}

// Iniciar o servidor
startServer(); // SegmentationService implementado com sucesso

// Tratamento de erros n√£o capturados
process.on('uncaughtException', (error) => {
  console.error('Erro n√£o capturado:', error);
  process.exit(1);
});

process.on('unhandledRejection', (reason, promise) => {
  console.error('Promise rejeitada n√£o tratada:', reason);
  process.exit(1);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('Recebido SIGTERM, encerrando servidor...');
  MetricsService.stopCollection();
  if (globalSegmentationService) {
    globalSegmentationService.stop();
  }
  server.close(() => {
    console.log('Servidor encerrado.');
    process.exit(0);
  });
});

process.on('SIGINT', () => {
  console.log('Recebido SIGINT, encerrando servidor...');
  MetricsService.stopCollection();
  if (globalSegmentationService) {
    globalSegmentationService.stop();
  }
  server.close(() => {
    console.log('Servidor encerrado.');
    process.exit(0);
  });
});

export { app, server, io };
// Restart trigger
